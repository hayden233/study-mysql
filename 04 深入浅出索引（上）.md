04 深入浅出索引（上）
============

深入浅出**索引**

这篇文章非常重要，它就像是武功心法，理解了它，后面很多数据库的招式你才能运用自如。

* * *

### 故事背景：国王的皇家大图书馆

想象一下，你不是数据库管理员，而是一位管理着皇家大图书馆的**首席图书管理员**。这座图书馆收藏着数千万卷羊皮卷轴（数据行），每一卷都记录着一位公民的信息。

国王（用户）时不时会提出要求：“快！帮我找到编号为 `ID=89757` 的公民的卷轴！”

如果没有一套好的查找方法，你只能带着手下，把几千万卷羊皮卷轴一卷一卷地打开看，这简直是场灾难。为了不被国王砍头，你必须设计一套高效的 **“卷轴检索目录”**——这就是 **“索引”**。

* * *

### 第一章：目录设计大赛 (索引模型)

你召集了图书馆里最聪明的三位学者，让他们各自提出一套目录设计方案。

#### 学者A的方案：“魔法传送阵” (哈希表)

* **设计**：这位学者是位魔法师。他建造了一个魔法传送阵。你只要对着传送阵念出公民的ID号（Key），它就能瞬间把你传送到存放对应卷轴的储藏室（Value）。

* **优点**：**单点查询**速度快到极致！念出ID，人就到了，几乎没有过程。

* **缺点**：国王如果下令：“把ID号在 `[10000, 20000]` 区间内所有公民的卷轴都找出来！” 这套魔法阵就傻眼了。因为它只能“点对点”传送，完全不理解“范围”的概念。你还是得老老实实地走遍每一个储藏室。

* **结论**：这个方案只适合“给我找ID号是XXX的”这种**等值查询**场景。

#### 学者B的方案：“完美顺序名册” (有序数组)

* **设计**：这位学者是位严谨的史官。他提议制作一本巨大的名册，把所有公民的ID号**从1到几千万完全按顺序**写下来，旁边标注卷轴的位置。

* **优点**：
  
  * **等值查询**：用“二分法”查找飞快。想找89757？先翻到名册中间，比89757大，那就往前翻一半...几次下来就能精确定位。
  
  * **范围查询**：同样飞快！用二分法找到10000的位置，然后往后一页一页地抄录，直到超过20000为止。

* **缺点**：**更新和插入是噩梦**。如果来了一位新公民，ID号恰好在中间，比如89758。为了在名册里加上他，你得把后面几百万个条目全部擦掉，然后依次往后挪一个位置，再把新条目写上。这工程量太大了！

* **结论**：这个方案只适合那些**不再变动**的“静态”资料库，比如“一百年前的人口普查档案”。

#### 学者C的方案：“多级导览图” (B+树)

* **设计**：这位学者是位建筑师。他提议，我们不要做一本大名册，而是建立一套**“多级导览系统”**。
  
  1. **图书馆大厅（根节点）**：有一张总导览图，告诉你“1-100万号去A区，101-200万号去B区...”。
  
  2. **区域入口（第二层）**：你到了A区，又有一张导览图，告诉你“1-10000号去第1排书架，10001-20000号去第2排书架...”。
  
  3. **书架尽头（叶子节点）**：你到了指定的书架，这里挂着一张详细的索引卡，上面写着“89757号卷轴，在本架第5行第3列”。

* 为什么是“多级”而不是“两级”？
  因为卷轴（数据）存放在遥远的地下仓库（磁盘），去一趟很耗时。我们希望尽量少跑几趟仓库。如果每张导览图能包含成百上千个指引，那么就算有几十亿卷轴，也只需要跑个三四趟（3-4次磁盘IO）就能找到。这就是为什么数据库不用二叉树（每次只能指2个方向），而用N叉树（B+树，每次能指上千个方向）。

* **结论**：这个方案查询速度很快，而且插入新数据时，通常只需要在某个书架的索引卡上增加一条记录，或者最多调整一下某个区域的导览图，成本可控。**这套方案大获全胜，成为了InnoDB储藏室的官方标准。**

* * *

### 第二章：InnoDB储藏室的独特设计 (索引即数据)

我们的 `InnoDB` 储藏室采用了“多级导览图”（B+树）方案，但它玩出了自己的花样。它有两种“导览图”：

#### 1. 主键索引 (聚簇索引)：【按号排序的卷轴本身】

这个最特别！InnoDB 储藏室没有一个单独存放卷轴的地方。卷轴本身就是按照ID号的顺序，整整齐齐地摆放在书架上的。

我们之前说的“多级导览图”的最后一层（叶子节点），指向的不是“索引卡”，而是那卷沉甸甸的、包含所有信息的原始卷轴。

这个“导览图 + 卷轴本体”合二为一的系统，就叫主键索引，也叫聚簇索引。

#### 2. 普通索引 (二级索引)：【按其他信息做的索引卡】

国王有时候会提些别的要求，比如：“把所有姓‘赵’的公民卷轴都找出来！”

为了应对这种需求，你就得再做一套按“姓氏”排列的索引卡。这张索引卡上是这么写的：

* “赵大 -> ID号: 1024”

* “赵二 -> ID号: 358_”

* ...

注意，这张索引卡上**只记录了“姓氏”和公民的“ID号”**，并没有记录公民的所有信息（比如年龄、住址等）。

#### 查询的区别：

* select * from T where ID=500 (按主键查)
  过程：直接查“主键导览图”，一路找到500号卷轴，拿起就走。（查1次树）

* select * from T where k=5 (按普通索引查，k是“姓氏”)
  过程：
  
  1. 先去查“姓氏索引卡”，找到姓氏为`k=5`的卡片，上面写着“此人ID号为500”。
  
  2. 再拿着这个ID号500，去查“主键导览图”，找到500号卷轴，拿起走人。
     这个先查普通索引，再拿主键去查主键索引的过程，就叫 **“回表”。（查2次树）**

**结论**：很明显，直接按主键ID查，比按其他条件查要少一个步骤，速度更快。

* * *

### 第三章：图书馆的日常维护 (索引维护)

* **有序插入 (自增主键)**：如果所有新来的公民都按顺序分配ID号（1001, 1002, 1003...），那他们的卷轴就可以一直往最新的书架上放，非常省事。

* **无序插入 (业务主键)**：如果用身份证号做主键，新来的公民身份证号可能在中间任何位置，你就得频繁地挪动现有书架上的卷轴，甚至要**“页分裂”**——当一个书架满了，不得不把一半的卷轴搬到新申请的空书架上，然后还要去更新上级导览图。这个过程非常影响性能。

#### 为什么推荐用自增ID做主键？

1. **写入性能好**：避免了“页分裂”，插入操作更快。

2. **节省空间**：所有“普通索引”（比如姓氏、地名索引卡）上，都必须记下对应卷轴的“主键”。
   
   * 如果主键是长长的一串身份证号（比如20个字符），那每张索引卡都会很厚重。
   
   * 如果主键是短短的一个数字ID（比如4个或8个字符），那每张索引卡都会很轻薄。
     整个图书馆的所有“索引卡”加起来，能省下巨大的空间！

所以，除非你的业务场景非常简单（比如就是个纯粹的K-V存储，只有主键索引），否则，使用**自增主增主键**通常是最佳实践。
