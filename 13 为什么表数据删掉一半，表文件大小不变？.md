好的，我们来深入探讨一个数据库管理员（DBA）和开发人员经常遇到的问题：**为什么我删除了表里一半的数据，但表文件的大小却一点都没变？**

这个问题背后，是 `InnoDB` 存储引擎对磁盘空间管理的机制。我们来一步步拆解。

-----

### 1\. 数据的删除流程：只是“打标记”，而非“擦除”

首先，我们要明白 `DELETE` 命令在 `InnoDB` 中是如何工作的。它并不像我们在电脑上删除一个文件那样，直接把空间释放给操作系统。

  * **记录（行）级别的删除**：
    当你执行一条 `DELETE` 语句删除某一行数据时，`InnoDB` 并不会立即将这行数据占用的空间抹掉。它只是将这条记录**标记为“已删除”**。这个位置就变成了一个“可复用”的空间，但它仍然是表文件的一部分。未来，如果有符合该位置范围的新数据插入，`InnoDB` **可能**会复用这个空间。

  * **数据页（Page）级别的删除**：
    `InnoDB` 的数据是按“页”（Page，默认16KB）来组织的。如果你删除了一个数据页上的**所有**记录，那么这个数据页就会被整个标记为“可复用”。相比于单个记录的复用，整个页面的复用更灵活，它可以被用于存放任何位置的新数据。

**核心结论是：**
`DELETE` 命令执行后，数据文件的大小并不会改变。它只是在文件内部产生了很多“空洞”或者“碎片”，这些空间在 `InnoDB` 内部被认为是可复用的，但并没有返还给操作系统。

**不止删除，插入和更新也会产生“空洞”：**

  * **随机插入**：如果数据不是按主键递增顺序插入，新数据就需要被放入已有的数据页中。如果页面已满，就会发生\*\*“页分裂”\*\*——`InnoDB` 会申请一个新页面，并将原页面的一部分数据挪过去，这样原页面和新页面都可能只被部分填充，留下了空洞。
  * **更新操作**：更新一个索引字段的值，可以看作是“删除旧值，插入新值”，同样会产生碎片。

因此，一张经过大量增删改操作的表，其数据文件中必然存在大量碎片，导致文件大小远大于其实际数据量。

-----

### 2\. 如何回收空间？—— 重建表

要彻底清除这些“空洞”，把空间还给操作系统，唯一的方法就是\*\*重建（Rebuild）\*\*这张表。

重建表的原理很简单：
**新建一个临时的、结构相同的新表，然后把原表中所有“活着”的数据，一行一行地、紧凑地读出来，再写入新表。写完后，用这个紧凑的新表替换掉原来的旧表。**

这个过程会消除所有因删除、更新、页分裂产生的碎片，让数据页的利用率达到最高，从而实现表空间的收缩。

在 MySQL 中，执行重建表最常用的命令是：

```sql
alter table T engine=InnoDB;
```

-----

### 3\. 重建表的工作方式：Online DDL

你可能会担心，重建一个大表会不会锁住整张表，导致业务长时间无法访问？

这取决于你的 MySQL 版本。

  * **MySQL 5.5 及之前（老方法，`ALGORITHM=COPY`）**：
    这个过程是**阻塞**的。MySQL 会创建一个临时的表，然后**锁住原表**，禁止一切读写，再把数据一行行拷贝过去。整个过程业务完全无法访问该表，对于线上业务是不可接受的。

  * **MySQL 5.6 及之后（新方法，Online DDL，`ALGORITHM=INPLACE`）**：
    这个过程得到了极大的优化，实现了\*\*“在线”\*\*操作，其流程大致如下：

    1.  建立一个临时的文件（在 InnoDB 内部，而不是 Server 层），开始扫描原表主键，并构建新的B+树。
    2.  在构建过程中，**允许业务对原表进行增删改操作**。这些新的变更会被记录到一个“行日志”（row log）中。
    3.  当临时文件构建完成后，将“行日志”中记录的变更应用到临时文件上，使其数据与原表同步。
    4.  最后，在一个**极短的时间窗口**内，获取一个排他锁，用临时文件替换掉原表的数据文件，完成DDL。

因为整个过程中，耗时最长的“拷贝数据”阶段是允许业务并发操作的，所以我们称之为\*\*“Online DDL”\*\*。

#### `Online` 和 `inplace` 的区别

  * **`inplace`**：表示 DDL 操作在 `InnoDB` 存储引擎**内部**完成，没有在 Server 层生成临时表。但它仍然需要创建临时文件，所以还是需要额外的磁盘空间。
  * **`Online`**：表示 DDL 操作在执行期间，**允许**并发的 DML 操作。

它们的关系是：**Online DDL 一定是 `inplace` 的，但 `inplace` 的 DDL 不一定是 Online 的**（例如，在 MySQL 8.0 之前，添加全文索引就是 `inplace` 但非 `Online` 的）。

#### `OPTIMIZE` vs. `ANALYZE` vs. `ALTER`

  * `OPTIMIZE TABLE t;`：对于 `InnoDB` 而言，它等价于 `ALTER TABLE t ENGINE=InnoDB;`，即重建表。
  * `ANALYZE TABLE t;`：**不重建表**。它只是重新对索引的统计信息进行采样，用于帮助优化器做出更准确的判断。

-----

### 结尾问题解析

> 假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：
>
> 1.  一个表t文件大小为1TB；
> 2.  对这个表执行 `alter table t engine=InnoDB`；
> 3.  发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了1.01TB。
>
> 你觉得可能是什么原因呢？

这是一个非常好的“意外”场景题，它说明了重建表也并非总是能完美地收缩空间。

**最可能的原因是：重建过程中，二级索引的随机插入导致了新的碎片。**

我们来分析一下 `alter table ...` 的重建过程：

1.  MySQL 会扫描**原表的主键索引**，因为主键索引是按主键顺序排列的，所以读取数据是非常高效的顺序读取。
2.  然后，它将这些数据**按主键顺序**插入到新的表中。这个过程对于\*\*主键索引（聚簇索引）\*\*来说是完美的，因为是顺序写入，新表的主键索引会非常紧凑，几乎没有碎片。
3.  **但是，问题出在二级索引上。**
      * 当每一行数据被插入新表时，`InnoDB` 也需要为这一行数据更新**所有的二级索引**。
      * 从原表读出来的数据是按主键 `id` 排序的，但对于二级索引的键值（比如 `name`、`age` 等字段）来说，这些值几乎是**完全随机、无序的**。
      * 对二级索引进行大量的随机插入，就会频繁地导致**页分裂**，从而在**新的二级索引中产生了大量新的碎片和“空洞”**。

**最终结果：**
你通过重建表，清除了主键索引和数据本身的碎片，节省了空间（比如节省了0.1TB）。但同时，由于随机插入，又在所有二级索引上制造了新的碎片，多占用了空间（比如多占用了0.11TB）。

两者相抵，最终表文件的大小不仅没变小，反而还可能稍微变大了一点。这种情况在**二级索引非常多**的大表上，更容易出现。