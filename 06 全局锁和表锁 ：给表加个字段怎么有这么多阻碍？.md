这次，我们要讨论的是“给一个书架区加一列”时，为什么会遇到重重阻碍。

今天的故事，主角是“锁”。锁，就是图书馆为了保证多人在同一时间读书、放书、改造书架时不出乱子，而定下的一系列“规矩”。

---

### 第一章：闭馆盘点 (全局锁)

国王偶尔会有一个最高指示：“我需要对整个图书馆的所有藏书，进行一次最最精确的“逻辑备份”（全库备份），也就是把每本书的内容都抄录一份，形成一个完美的时间切片。”

#### 为什么要“闭馆”？
如果不闭馆，会发生什么？
想象一下，你的抄录员正在工作。
1.  他刚把“财务部”的账本（账户余额表）抄完。
2.  就在这时，一个用户“张三”进来，买了一本书，财务官立刻在**原始账本**上给他的余额扣了钱，并在“已购课程部”的**原始名册**（用户课程表）上增加了记录。
3.  然后，你的抄录员才慢悠悠地走到“已购课程部”，开始抄录这里的名册。

**结果呢？** 你备份出来的这份档案，出现了“张三的余额没少，但购买记录里却多了一本书”的灵异事件。这份备份是**逻辑不一致**的，是废品。

#### 如何实现“闭馆”？
有两种方式，效果类似，但我们推荐其中一种。

* **方法一（推荐）：`Flush tables with read lock (FTWRL)`**
    这相当于你通过广播，向全馆大喊一声：“**现在开始盘点，所有人放下手中的笔，不准修改任何书籍内容，不准上架新书，不准提交修改申请！可以继续阅读，但不能有任何写操作！**”
    * **效果**：整个图书馆进入严格的“只读”状态。
    * **优点**：非常可靠。如果你这个广播员（客户端）不小心掉线了，图书馆的安保系统（MySQL）会自动解除这个只读状态，让图书馆恢复正常。比较安全。

* **方法二（不推荐）：`set global readonly=true`**
    这相当于你跑到图书馆大门口，把“营业中”的牌子，手动翻成“内部整理，暂停写入”。
    * **为什么不推荐？**
        1.  **影响面大**：有些自动化系统会通过看门口这块牌子来判断这是“主馆”还是“分馆”，你随便翻牌子，可能会让别的系统产生误判。
        2.  **风险高**：如果你翻完牌子后，自己不小心掉线了，这块“只读”的牌子会**一直挂在那里**！整个图书馆将永久性地无法写入，直到有人手动把它翻回来。这是个巨大的风险。

#### “闭馆”的替代方案：MVCC
对于我们现代化的 `InnoDB` 书库，其实有更优雅的方式，就是我们上一章提到的“魔法相机”（MVCC）。
当使用 `mysqldump --single-transaction` 工具时，它会在备份开始时，用“魔法相机”拍下一张整个图书馆的“一致性快照”。抄录员就对着这张照片抄录，而图书馆内部依然可以正常进行读写操作，互不干扰。

**结论**：如果你的图书馆全部是 `InnoDB` 这种现代化书库，请尽量使用“魔法相机”方案。只有当你需要备份那些老旧的、不支持“魔法相机”的 `MyISAM` 书库时，才需要使用 `FTWRL` 这种“闭馆盘点”的笨办法。

---

### 第二章：装修一个房间 (表级锁)

给一个表加字段，就像是要**装修图书馆里的一个房间**（比如“历史区”）。这也会涉及到“锁门”的问题。

表级锁主要有两种，一种是老式的“门锁”，一种是现代的、自动的“门禁系统”。

#### 1. 老式门锁：`lock tables`
语法是 `lock tables ... read/write`。这相当于你拿一把大锁，手动把“历史区”的门锁上，并挂上“只许读”或“不许进”的牌子。
这种方式非常霸道，会把整个房间都锁住。在 `InnoDB` 这种可以精确到锁住某一排书架甚至某一本书（行锁）的现代书库里，这种锁住整个房间的笨重做法，已经很少使用了。

#### 2. 自动门禁系统：元数据锁 (MDL, MetaData Lock)

这是今天故事的重点，也是非常容易“踩坑”的地方。`InnoDB` 书库的每个房间门口，都有一套看不见的、全自动的门禁系统。

* **规则一（读锁）**：当你只是进去**读写书本内容（增删改查 DML）**时，门禁系统会自动给你发一张**“绿色通行证”**。这张证是共享的，很多人可以同时拿着“绿色通行证”在房间里看书。
* **规则二（写锁）**：当你要**装修这个房间（修改表结构 DDL）**时，比如要加一排书架（加字段），你必须申请一张**“红色施工证”**。这张证是排他的。
* **规则三（互斥规则）**：
    * 门禁系统**不会**在有人拿着“绿色通行证”的时候，发放“红色施工证”。（要装修，必须等里面的人都出来）
    * 门禁系统也**不会**在有人申请“红色施工证”的时候，再给后面的人发“绿色通行证”。（要装修，后面的人不许再进去了，都得在外面排队）

#### “门禁系统”引发的惨案

现在，我们来看一场由 MDL 锁引发的“交通堵塞”：

1.  `Session A`：一个“慢性子”的读者，进“历史区”开始读一本很厚的书（一个开启了但未提交的长事务）。门禁系统给他发了一张**“绿色通行证”**。
2.  `Session C`：一个“装修队”，想要进去加一排书架（`ALTER TABLE`）。他来到门口，看到里面还有人（`Session A` 的“绿色通行证”还在），于是他只好在门口排队等着，同时举起了**“准备施工”**的牌子（申请MDL写锁，被阻塞）。
3.  `Session B, D, E, F...`：这时，陆陆续续来了很多其他想进“历史区”看书的读者。他们走到门口，看到了“装修队”举着“准备施工”的牌子，根据“规则三”，他们**也必须排在装修队后面**。

**灾难发生了！**
仅仅因为“慢性子读者A”一直不出来（事务不提交），导致“装修队C”进不去，而“装修队C”又堵住了后面所有想进去看书的人。整个“历史区”（这张表）的门口排起了长龙，完全**“堵死”**了，无法进行任何读写。如果客户端还有重试机制，更多的请求会涌入，最终可能导致整个图书馆（数据库）因为排队人数过多而崩溃。

**核心原因**：MDL 锁会**持续到整个事务结束才释放**。`Session A` 的长事务，就是这场灾难的罪魁祸首。

#### 如何安全地“装修”？
1.  **解决长事务**：在打算“装修”（DDL）前，先去 `information_schema.innodb_trx` 表里查一下，有没有“慢性子读者”（长事务）。如果有，要么等他读完，要么把他“请”出去（`kill` 掉）。
2.  **设置等待时间**：对于热门的房间（热点表），装修请求可以更“礼貌”一些。MariaDB/AliSQL 支持 `ALTER TABLE ... WAIT N` 语法，相当于告诉装修队：“你们就在门口等 N 秒，如果能进去就装，等不到就先撤，别堵着门，我们下次再来试试。”

### 总结

* **全局锁**：用于全库逻辑备份。`InnoDB` 表为主的库，优先使用 `mysqldump --single-transaction`。
* **表锁 (`lock tables`)**：老旧的机制，`InnoDB` 环境下应避免使用。
* **MDL锁**：是自动的表结构锁。做 DDL 操作时，一定要警惕它被长事务阻塞，从而引发连锁反应，堵死所有后续操作。**安全变更，先查长事务**，是DBA的黄金法则。