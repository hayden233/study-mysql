`select count(*)` 为什么这么慢，以及我们应该如何应对。

-----

### 1\. `COUNT(*)` 为什么在 InnoDB 中很慢？

首先要明确，`COUNT(*)` 的效率与表的存储引擎息息相关。

  * **MyISAM 引擎**：非常快。MyISAM 会在磁盘上直接存储一个表的总行数。执行 `COUNT(*)` 时，它只需读取这个预存的数字即可，所以是瞬间完成的。但这背后牺牲的是事务支持。

  * **InnoDB 引擎**：很慢。`InnoDB` 是我们最常用的引擎，它**没有**像 MyISAM 那样存储一个现成的总行数。当执行 `COUNT(*)` 时，它必须一行一行地将数据从存储引擎中读出来，然后累积计数。表越大，这个过程就越慢。

#### 为什么 InnoDB 不把总行数存起来？

根本原因在于 `InnoDB` 实现了**多版本并发控制（MVCC）**，以支持高并发和事务。

在 MVCC 机制下，数据库中可能同时存在多个“版本”的数据。在同一个时间点，不同的事务（Session）看到的“世界”是不同的。

我们来看文章中的例子：

  * **会话A** 启动了一个“可重复读”事务，它看到的行数，将永远是它启动那一刻的行数（比如10000行）。
  * **会-话B** 在自己的事务中插入了一行，它看到的行数是10001行。
  * **会话C** 自动提交插入了一行，它看到的行数是10002行。

你看，对于“这个表到底有多少行？”这个问题，在 `InnoDB` 的世界里，**没有唯一的、全局都正确的答案**。行数取决于你是谁（哪个事务）、你在哪个时间点看（你的事务视图）。

因此，`InnoDB` 别无选择，只能在每次你发起 `COUNT(*)` 请求时，根据你当前的事务视图，老老实实地去遍历、判断、计数那些对你“可见”的行。

**`InnoDB` 的一个小优化**：在执行 `COUNT(*)` 时，优化器会选择表里**最小的那棵二级索引树**去遍历。因为二级索引只包含索引列和主键，比包含整行数据的主键索引要小得多，这样可以有效减少 I/O 消耗。

**`SHOW TABLE STATUS` 可信吗？**：不可信。该命令显示的 `TABLE_ROWS` 值，是根据采样估算出来的，误差可能高达40%\~50%，不能用于精确计数。

### 2\. 如何解决 `COUNT(*)` 慢的问题？

既然直接查询很慢，我们就需要自己想办法来维护这个计数。

#### 方法一：使用缓存系统（如 Redis）

这是很多人首先想到的方案。在 Redis 中维护一个计数器，每次向 MySQL 表中 `INSERT` 一行，就对 Redis 执行 `INCR`；`DELETE` 一行，就执行 `DECR`。

  * **优点**：读写速度都非常快。
  * **缺点**：
    1.  **数据丢失风险**：如果 Redis 发生故障或重启，内存中的计数值可能会丢失。虽然可以通过重启后重新从数据库 `COUNT(*)` 一次来恢复，但这期间计数是不准的。
    2.  **逻辑不一致的硬伤**：这是更严重的问题。因为 MySQL 和 Redis 是两个独立的系统，它们之间的操作无法保证**原子性**。这会导致“数据和计数对不上”的情况。
          * **场景1**：程序先写 MySQL 成功，再去更新 Redis。在一个高并发的时刻，一个用户可能刚好看到了 MySQL 里的新数据，但 Redis 的计数还没来得及更新。
          * **场景2**：程序先更新 Redis 成功，再去写 MySQL。用户可能看到了 Redis 里的新计数，但 MySQL 里的新数据还没写入，查不到。

#### 方法二：在数据库中创建计数表（推荐方案）

这个方案的核心是利用数据库自身的**事务**特性来解决一致性问题。

1.  **设计**：在数据库中，单独创建一张表，比如 `counts_table`，里面只有一行一列，专门用来存储某个表的总行数。

2.  **操作**：将“向业务表插入数据”和“更新计数表”这两个操作，**放在同一个事务里**。

    ```sql
    START TRANSACTION;
    INSERT INTO business_table (col1, col2) VALUES ('a', 'b');
    UPDATE counts_table SET total_rows = total_rows + 1 WHERE table_name = 'business_table';
    COMMIT;
    ```

3.  **为什么这个方法可行？**
    因为**事务的隔离性**。当一个读请求（比如查询页面）到来时，它看到的要么是“写事务”**提交前**的状态（数据和计数都是旧的），要么是“写事务”**提交后**的状态（数据和计数都是新的）。它绝对不会看到“数据是新的，计数是旧的”这种中间状态。这就完美地保证了逻辑上的一致性。

### 3\. 不同 `COUNT` 用法的性能对比

这是一个常见的面试题，结论如下：

`count(*)` ≈ `count(1)` \> `count(主键id)` \> `count(字段)`

  * **`count(*)`**：MySQL 对它有专门的优化。它不关心具体列，只关心行数，所以会选择最小的索引来遍历，效率最高。
  * **`count(1)`**：效果和 `count(*)` 类似。它不对列进行取值，只是为每一行放一个数字`1`，然后计算个数。
  * **`count(主键id)`**：需要遍历，并且把每一行的`id`值取出来，再返回给 Server 层，Server 层再进行累加。相比前两者，多了一步取值的操作，效率稍低。
  * **`count(字段)`**：
      * 如果字段定义为 `NOT NULL`，则从每一行读出该字段，累加。
      * 如果字段允许为 `NULL`，则需要从每一行读出该字段，并且**判断一下是否为 `NULL`**，不为 `NULL` 才累加。这是最慢的。

**最佳实践**：直接使用 `select count(*) from ...`。它的语义最清晰（“计算所有行”），并且 MySQL 对它做了专门优化，性能最好。

-----

### 结尾问题解析

> 在使用“数据库计数表”的方案中，从并发系统性能的角度考虑，在一个事务里，应该先 `INSERT` 操作记录，还是应该先 `UPDATE` 计数表呢？

**答案：应该先 `INSERT` 操作记录，最后再 `UPDATE` 计数表。**

```sql
START TRANSACTION;
-- 步骤一：插入业务数据
INSERT INTO business_table ...; 
-- 步骤二：更新计数器
UPDATE counts_table ...;
COMMIT;
```

**原因分析：**

这个问题考察的是**行锁的竞争范围和持有时间**。

1.  **`INSERT` 操作**：向业务表中插入一条新记录，通常锁住的是新插入的这一行，或者是一个很小的“间隙”。不同的 `INSERT` 操作之间，锁冲突的概率非常低。

2.  **`UPDATE counts_table` 操作**：这个操作的目标是**计数表里的同一行数据**。这意味着，**所有**需要新增业务数据的并发事务，最终都会来竞争这**唯一一行**的行锁。这个计数行是一个绝对的\*\*“热点”\*\*。

3.  **两阶段锁协议**：我们知道，事务中的锁，一旦加上，就要等到事务结束时（`COMMIT` 或 `ROLLBACK`）才会释放。

**结合以上三点，我们的优化目标是：让这个“热点行”的锁，被持有的时间尽可能地短。**

  * **如果先 `UPDATE` 计数表**：事务一开始就锁住了这个最繁忙的“热点行”，然后才去慢悠悠地执行 `INSERT` 操作。在这整个过程中，其他所有想更新计数的事务，都必须在计数表前排队等待，系统的并发能力会急剧下降。
  * **如果先 `INSERT` 业务表**：事务先完成不怎么冲突的 `INSERT` 操作，只在事务即将结束的最后一刻，才去申请那个“热点行”的锁，并快速执行 `UPDATE` 和 `COMMIT`。这样，热点行被锁定的时间被压缩到了最短，大大减少了事务之间的锁等待，提升了系统的整体并发性能。

这个思路，和我们在第7篇文章中讲到的“电影票”案例的优化思路（“把最抢手的钥匙，留到最后再拿”）是完全一致的。