我们继续以首席图书管理员的身份，探索 `InnoDB` 这座大图书馆里更深层次的效率奥秘。

上一章我们明白了，通过“姓氏索引卡”（二级索引）找人，需要先查卡，再根据卡上的ID号去主书库（主键索引）拿卷轴，这个过程叫“回表”。现在的问题是，我们能把这个过程变得更快吗？

-----

### 第一章：能写在卡片上的信息，就别进书库了 (覆盖索引)

国王又提了一个新需求：“我不需要看所有姓‘张’的公民的全部资料，我只要一份\*\*只包含他们‘姓名’和‘ID号’\*\*的清单就行了。”

#### 过去的笨办法（需要回表）：

1.  你去查“姓名索引卡”，找到第一张姓“张”的卡，上面写着 `[ 姓名: '张三', 主键ID: 1001 ]`。
2.  为了确认“姓名”是“张三”，你还是得拿着 `ID: 1001` 跑去主书库，把那份沉甸甸的卷轴取出来，打开一看，哦，姓名是“张三”，ID是“1001”，然后把这两个信息抄录下来。
3.  接着你回到索引卡柜，找下一张姓“张”的卡片，再重复一遍跑腿的活儿... 这样来来回回，非常累。

#### 你的聪明才智（使用覆盖索引）：

你突然灵光一闪：“国王要的‘姓名’和‘ID号’，这不都清清楚楚地写在我的‘姓名索引卡’上了吗？我为什么还要傻乎乎地跑回主书库去取那份原始卷轴呢？”

于是，你的工作流程变成了：

1.  你站在“姓名索引卡”柜子前。
2.  拿起第一张姓“张”的卡，直接把上面的 `[ 姓名: '张三', 主键ID: 1001 ]` 抄下来。
3.  拿起下一张，再抄下来...
4.  全程你一步都没离开过索引卡柜！

这种**索引卡上已经包含了查询所需全部信息，无需再回到主书库（主键索引）去取原始卷轴**的情况，就叫做\*\*“覆盖索引” (Covering Index)\*\*。

**结论**：覆盖索引是性能优化的大杀器。它把“回表”这个耗时的步骤给省略了，极大地提升了查询效率。这也是为什么，有时候我们会“冗余”地建立一个联合索引（比如 `(身份证号, 姓名)`），就是为了让“根据身份证号查姓名”这种高频操作能用上覆盖索引，一步到位。

-----

### 第二章：目录要从左往右看 (最左前缀原则)

为了提高效率，你精心制作了一套联合索引卡，上面的信息是**严格按照 `(姓名, 年龄)` 的顺序来排列的**。也就是说，先按姓名的字母顺序排，姓名相同时，再按年龄从小到大排。

现在，国王有几个不同的命令：

  * **命令A: `where name = '张三'`**
    **能用上这套索引卡吗？能！** 因为卡片首先就是按姓名排的，你可以非常快地定位到所有姓“张三”的区域。

  * **命令B: `where name like '张%'`**
    **能用吗？也能！** 你可以快速定位到“张”字开头的区域，然后向后遍历即可。

  * **命令C: `where age = 10`**
    **能用吗？完全不能！** 这套卡片是先按姓名排的。“10岁”这个信息，散落在“李四”、“王五”、“赵六”等各个不同的姓名区域下，是完全无序的。只按年龄查，这套索引卡帮不上任何忙，你还不如把所有卡片翻一遍。

这就是\*\*“最左前缀原则”**：使用联合索引时，你的查询条件必须从索引的**最左边的字段开始，并且不能跳过中间的字段\*\*。

  * `where name='张三' and age=10` -\> 能用上 `(name, age)` 完整索引。
  * `where name='张三'` -\> 能用上 `(name)` 部分的索引。
  * `where age=10` -\> 完全用不上 `(name, age)` 索引。

**如何安排字段顺序？**

1.  **复用性优先**：如果创建了 `(a, b)` 索引，就等于免费得到了一个 `(a)` 索引。思考一下，怎么安排顺序，可以让你少建几个独立的索引。
2.  **空间优先**：如果 `a` 和 `b` 两个字段的查询都很频繁，必须建 `(a,b)` 和 `(b)` 两个索引，那么建议让选择性更好或更常用的字段放在前面。

-----

### 第三章：聪明的图书管理员助理 (索引下推)

国王又提了一个更复杂的需求：“把所有姓‘张’，并且年龄等于10岁的男孩（ismale=1）的卷轴都找出来！”

SQL: `select * from tuser where name like '张%' and age=10 and ismale=1;`

我们还是用 `(姓名, 年龄)` 这套索引卡。

#### 过去那个“一根筋”的助理 (MySQL 5.6 之前)：

1.  他看到 `name like '张%'`，于是从索引卡里找到了第一张符合的卡片，比如 `[ 姓名:'张一', 年龄:8 ]`。
2.  他是个“一根筋”，只认最左边的 `name`。他心想：“符合‘张%’！”，然后**立刻跑回主书库**，把“张一”的完整卷轴拿了出来。
3.  拿回来之后，才开始检查其他条件：“年龄是8岁，不是10岁，淘汰！”，“性别...”，这个过程叫**回表**。
4.  他回到索引卡柜，拿起下一张 `[ 姓名:'张二', 年龄:10 ]`，又立刻跑回主书库...
5.  ...他为很多“年龄不符”的记录，白跑了无数趟冤枉路。

#### 现在这个“聪明的”助理 (MySQL 5.6+ 的索引下推 - ICP)：

1.  他看到 `name like '张%'`，找到了第一张符合的卡片 `[ 姓名:'张一', 年龄:8 ]`。
2.  他很“聪明”，没有立刻跑腿。他会把**整张索引卡的信息都看完**。他发现这张卡上写着“年龄: 8”，而国王的要求是“年龄: 10”。
3.  他心想：“这张卡片不完全符合要求，根本没必要去拿原始卷轴了！” 于是他**直接把这张卡片扔掉**，去看下一张。
4.  他拿起下一张卡 `[ 姓名:'张二', 年龄:10 ]`。他再次检查：“姓名符合‘张%’，年龄也符合10岁，好！这个有希望！”
5.  **直到这时，他才动身跑回主书库**，去拿“张二”的完整卷轴，回来再检查“性别”是否为男孩。

**索引下推 (Index Condition Pushdown)** 的本质就是，把原本需要在 Server 层（拿到完整数据后）做的条件判断，**“下推”** 到了存储引擎层。在遍历索引的过程中，就利用索引自身包含的字段，尽可能地过滤掉无效数据，从而**极大地减少了“回表”的次数**。

-----

### 结尾问题解析

最后，我们来分析一下文章结尾那个非常棒的问题。

> DBA小吕的公司有一个表，主键是 `(a, b)`，同时还有 `c`、`ca(c,a)`、`cb(c,b)` 这三个二级索引。同事说建 `ca` 和 `cb` 是为了下面这两个查询：
>
> ```sql
> select * from geek where c=N order by a limit 1;
> select * from geek where c=N order by b limit 1;
> ```
>
> 这位同事的解释对吗？这两个索引是否都是必须的？

**我的分析如下：**

这个问题考察的是“**索引的有序性**”如何被 `order by` 利用。

1.  **我们先看索引 `c` 的结构**：

      * 在InnoDB中，二级索引的叶子节点，除了包含索引自身的列，还会自动附带上**主键**的值。
      * 这个表的主键是 `(a, b)`。
      * 所以，索引 `c` 的叶子节点上，实际存储的数据结构是 `(c, a, b)`，并且是**先按 `c` 排序，`c` 相同时，再按 `a` 排序，`a` 再相同时，再按 `b` 排序**。

2.  **分析第一个查询：`... where c=N order by a limit 1`**

      * 当 `where c=N` 时，数据库通过索引 `c` 能快速定位到所有 `c` 等于 `N` 的记录。
      * 因为索引 `c` 的数据本身就是 `c` 相同，再按 `a` 排序的，所以这些 `c=N` 的记录天然就是**按 `a` 有序的**！
      * 因此，`order by a` 这个操作**完全不需要额外的排序**，数据库只需要从找到的第一条记录开始，取出第一条，就是结果。
      * **结论**：单独的索引 `c` 就足以高效地支持第一个查询。索引 `ca(c,a)` 是**完全冗余**的，因为它的排序特性和索引 `c` 完全一样。

3.  **分析第二个查询：`... where c=N order by b limit 1`**

      * 同样，数据库通过索引 `c` 找到了所有 `c=N` 的记录。
      * 但是，这批记录是按 `a` 排序的，而不是按 `b` 排序的。如果 `a` 的值有很多种，那么 `b` 的值在这些记录中是**无序**的。
      * 所以，如果只用索引 `c`，数据库必须把所有 `c=N` 的记录都取出来（可能需要回表），然后在内存中进行一次**文件排序 (filesort)**，才能找出按 `b` 排序的第一条记录。当 `c=N` 的记录很多时，这个开销会很大。
      * 而如果使用了 `cb(c,b)` 这个索引，它的数据结构是 `(c, b, a)`。当 `where c=N` 时，找到的记录天然就是**按 `b` 有序的**！`order by b` 也不需要额外排序。
      * **结论**：为了高效支持第二个查询，避免 `filesort`，索引 `cb(c,b)` 是**必须的**。

**最终答案：**

这位同事的解释**部分正确**。

  * 为了 `select * from geek where c=N order by b limit 1;` 这个查询，创建 `cb(c,b)` 索引是**必须且有效的**，它可以避免文件排序。
  * 为了 `select * from geek where c=N order by a limit 1;` 这个查询，单独的索引 `c` 就已经足够了，`ca(c,a)` 索引是**完全不必要的冗余索引**，可以放心删除。# 05 深入浅出索引（下）