# 03 事务隔离：为什么你改了我还看不见？

“事务隔离”核心问题是：“为什么有时候，别的事务明明修改了数据，我在我的事务里却看不到？”

为了搞清楚这个问题，我们还是回到那个“图书馆”的场景。

* * *

### 故事背景：多人同时在图书馆编辑资料

想象一下，你（事务A）和你的同事小王（事务B）正在**同时**使用一套共享的百科全书（数据库）来编写报告。如果没有一套协作规则，场面肯定会乱成一团。

比如，可能会发生以下几种混乱情况：

1. **脏读 (Dirty Read)**：小王正在修改一个词条，他刚写了一半，还没保存（事务未提交），你就把这半成品抄到了你的报告里。结果小王发现写错了，撤销了修改，你的报告里就留下了一个错误信息。

2. **不可重复读 (Non-Repeatable Read)**：你先读了一遍词条内容，是“A”。这时小王修改了这个词条为“B”并保存了（事务提交）。你过了一会儿再读一遍，发现内容变成了“B”。对于你来说，同一个词条读了两遍结果却不一样，这就可能让你的报告逻辑混乱。

3. **幻读 (Phantom Read)**：你先统计了一下“历史”卷里有多少个词条，数出来是10个。这时，小王在“历史”卷里新增了一个词条并保存了。你再次统计，发现竟然变成了11个！就像凭空多出来一个“幻影”词条一样。

为了解决这些协作中的混乱问题，图书馆（MySQL）引入了 **“协作规则”** ，也就是 **“事务隔离级别”**。规则越严格，协作越安全，但效率也可能越低。

* * *

### 四种协作规则 (隔离级别)

我们可以把你看数据的行为，想象成你在用不同的方式 **“拍照”或“截屏”** 来获取资料。

#### 1. 读未提交 (Read Uncommitted)：【直播模式】

* **规则**：这是最宽松的规则。你就像在看小王的**屏幕直播**。他打的每一个字，甚至还没保存的草稿，你都能立刻看到。

* **优点**：速度最快，因为没有任何限制。

* **缺点**：非常不安全，你会看到很多未经确认的“脏数据”。所以，现实中几乎没人用。

#### 2. 读提交 (Read Committed)：【每次都拍新照片】

* **规则**：你每次想看资料时，都会**重新拍一张全新的快照**。你只能看到小王**已经保存（提交）**的版本。

* **举例**：
  
  * 你拍了第一张照片（第一次`SELECT`），看到词条内容是 "1"。
  
  * 小王把词条改成 "2"，并**保存**了。
  
  * 你拍了第二张照片（第二次`SELECT`），看到的就变成了 "2"。

* **特点**：解决了“脏读”，但没解决“不可重复读”。这是 Oracle 等数据库的默认规则。

#### 3. 可重复读 (Repeatable Read)：【只看第一张照片】

* **规则**：这是 MySQL (InnoDB) 的默认规则。当你开始工作（开启事务）时，你会先给整个图书馆拍一张**完整的、唯一的快照**。在你的整个工作期间（事务结束前），**无论你看多少次，你都只看这张最开始的快照**。

* **举例（回答了标题的问题）**：
  
  * 你开启事务，拍了一张快照，看到词条内容是 "1"。
  
  * 小王把词条改成 "2"，并**保存**了。（这相当于他修改了“真实”的百科全书）
  
  * 你再次查看，因为你**仍然在看你最初的那张快照**，所以看到的内容**还是 "1"**。

* “为什么你改了我还看不见？”
  答案：因为你在你的事务里，看的不是“实时数据”，而是你事务刚开始时拍下的那张“历史快照”。

#### 4. 串行化 (Serializable)：【我用的时候你别动】

* **规则**：最严格的规则。你开始读或写一个词条时，就会把它**锁起来**。在你用完（事务提交）之前，任何其他人（包括小王）都不能动它，只能在外面排队等着。

* **优点**：绝对安全，所有混乱情况都不会发生。

* **缺点**：效率极低，因为所有并发操作都变成了排队执行。

* * *

### “历史快照”的魔法：MVCC

你可能会好奇，MySQL 是如何实现“只看第一张照片”这种神奇操作的？难道真的把整个数据库复制了一份吗？当然不是。

这背后的魔法叫做 **MVCC (Multi-Version Concurrency Control)，即多版本并发控制**。

我们可以把它想象成**“文档的版本历史记录”**，就像你在 Google Docs 或 Word 里能看到的修订记录一样。

* 当一个数据被修改时，MySQL 不会直接覆盖掉旧数据，而是会**在“回滚日志 (undo log)”中保留旧的版本**。

* 比如，一个值从 1 -> 2 -> 3 -> 4，它的历史版本链就像 `4 <- 3 <- 2 <- 1`。

* 当你开启事务时，你会获得一个“版本号”（Read View）。当你去读取数据时，MySQL 会从最新的版本（比如 4）开始，沿着版本链往回找，找到第一个**对你这个“版本号”可见的**版本。

* 对于启动早的事务，它能看到的版本就老；对于启动晚的事务，它能看到的版本就新。

这就是为什么，你和小王可以在互不干扰的情况下，同时看到一本书的不同“版本”。

* * *

### 为什么要避免“长事务”？

现在我们知道了，MVCC 依赖“回滚日志”来保存历史版本。那么“长事务”——也就是一个**开启了很久却不提交的事务**——会带来什么问题呢？

* **问题**：假设你开启了一个事务（拍了一张快照），然后就去喝了三个小时的茶。

* **后果**：在这三个小时里，数据库里发生的所有修改，**它们对应的旧版本（回滚日志）全都不敢删除！** 因为系统认为，你这个“老古董”事务随时可能会回来看这些旧版本的数据。

* **灾难**：这会导致**回滚日志越积越多，极度消耗磁盘空间**，甚至可能拖垮整个数据库。

这就是为什么文章强烈建议**不要使用长事务**，并且在使用完事务后要及时 `commit` 或 `rollback`。

### 总结一下

* **隔离级别**：就是数据库为了解决多用户并发协作时的“脏读、不可重复读、幻读”等问题而设计的**四套协作规则**。

* **可重复读 (MySQL默认)**：核心在于“**事务开启时拍快照**”。在事务结束前，你看到的所有数据都来自这张快照，所以你看不到别人的修改。

* **MVCC (多版本并发控制)**：是实现“快照”功能的底层技术，通过保存数据的**历史版本链 (undo log)**，让不同事务能看到不同版本的数据，实现了读写不冲突。

* **长事务的危害**：会导致过时的历史版本 (undo log) 无法被清理，大量占用存储空间，是数据库维护中的一个大敌。

希望这次的“图书馆故事”能让你对事务隔离有一个清晰、生动的理解！


