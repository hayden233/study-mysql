这篇文章触及了 `InnoDB` 事务与锁机制中最精妙、也最容易让人困惑的地方。我们继续用生动的故事，把这个“又隔离又不隔离”的“薛定谔的事务”讲清楚。

### 故事背景：时空调查局

想象一下，`MySQL` 不是数据库，而是一个“时空调查局”。每一个“事务”，就是一位被派往过去执行任务的“时空特工”。

我们之前学到的“可重复读”，就像是给每位特工配备了一件超级装备：**“时间静止护目镜”**。

#### “时间静止护目镜” (一致性读视图 / Consistent Read View)

当一位特工（比如事务A）开始任务时（`START TRANSACTION`），调查局会为他启动这副护目镜。这副护目镜会“锁定”在他出发那一刻的全宇宙时空快照。

  * **工作原理**：无论特工A在任务中途，外界（其他事务）发生了多少翻天覆地的变化（比如B把k从1改成了2，C又改成了3），他透过护目镜看到的，永远是他出发时那个**静止、不变**的世界。
  * **实现方式**：这副护目镜非常智能，它内置了“历史回溯”功能（`undo log`）。当特工A看到一个被修改过的物体时，护目镜会自动播放它的“历史录像带”，直到回溯到在他出发前就已经存在的那个版本为止。

这就是\*\*“一致性读” (Consistent Read)\*\*。对于普通的 `SELECT` 查询，特工都是戴着这副护-目镜去观察世界的，所以他能做到“两耳不闻窗外事”，世界对他来说是“隔离”的。

-----

### 核心矛盾：特工的两种工作模式

现在，文章开头的那个矛盾就来了：如果世界对特工A是静止不变的，那他为什么会被其他特工的“锁”给挡住去路呢？

答案是：**因为特工有两种截然不同的工作模式！**

#### 模式一：观察模式 (戴着护目镜) - 一致性读

这是特工的默认模式，对应普通的 `SELECT` 语句。

  * 在文章的例子中，特工A的任务只是“观察”。他从头到尾都戴着他的“时间静止护目镜”。
  * 虽然在他观察期间，特工C把k改成了2，特工B又把k改成了3，但在特工A的护目镜里，这些都是他出发后才发生的“未来事件”，通通被屏蔽了。护目镜不断“回溯历史”，最终给他呈现的，还是他出发时看到的那个原始版本 `k=1`。
  * 所以，**事务A查到的k是1**。这体现了事务的\*\*“隔离性”\*\*。

#### 模式二：干预模式 (摘下护目镜) - 当前读

当特工的任务不是观察，而是要**改变历史**（`UPDATE`, `DELETE`, `INSERT`, `SELECT ... FOR UPDATE`）时，情况就完全不同了。

**时空调查局有一条铁律：你不能基于一个“虚假、静止的快照”去修改真实的历史。你必须先看清楚“当前”的真实情况，才能动手。**

  * 在文章的例子中，特工B的任务是 `UPDATE t SET k=k+1 WHERE id=1`。
  * 要执行这个任务，他**必须摘下他的“时间静止护目镜”**，用肉眼去观察 `id=1` 这个物体**在当前时间点上，最新的、已经被提交的版本**。这个动作，就叫做\*\*“当前读” (Current Read)\*\*。
  * 在他动手前，特工C已经完成了任务（`k`被改成了2并提交）。所以特工B进行“当前读”时，看到的真实情况是 `k=2`。
  * 他基于这个“当前值”执行 `k=k+1`，得到了 `k=3`。然后他提交自己的修改，让 `k=3` 成为了新的“当前现实”。
  * 所以，当他自己再去查询时，他看到的是自己刚刚完成的、最新的成果 `k=3`。

-----

### 锁，在何时出现？

当一个特工**摘下护目镜，准备对一个物体进行“当前读”并修改**时，为了防止其他特工也来同时修改这个物体造成错乱，他必须先用一个“时空锁定装置”（行锁）把这个物体锁住。

  * 在文章的最后一个例子里，特工C' 修改了 `k=2` 但**没有提交**，这意味着他用“锁定装置”锁住了 `id=1` 这个物体，并且人还没走。
  * 当特工B也想修改 `id=1` 时，他也需要进行“当前读”，也需要使用“锁定装置”，但他发现装置已经被C'占用了。
  * 于是，特工B就被**阻塞**了，只能在旁边等待，直到特工C'完成任务、释放锁定装置为止。

### 结论：隔离，但不是绝对真空

现在，我们可以回答最初的问题了：**事务到底是隔离的还是不隔离的？**

答案是：**它是一种“有条件的隔离”**。

  * 当你的事务只是在做**普通查询（`SELECT`）时，它通过 MVCC 和“一致性读”，为你提供了一个高度隔离的、如同静止快照般的环境。这时，它是隔离的**。
  * 当你的事务需要**修改数据（`UPDATE`/`DELETE` 等）时，它必须遵循规则，切换到“当前读”模式，去读取和锁定那个唯一、真实的最新版本的数据。这时，它会和其它同样想修改该数据的事务产生交互和锁竞争**，也就能“看”到其它已提交事务的修改。这时，它又是**不隔离的**。

**“可重复读”这个隔离级别，真正要保证的核心是“一个事务在普通读**的情况下，前后多次读取到的数据是一致的”，而它巧妙地通过“当前读”的机制，保证了在修改数据时，不会因为操作了过时的快-快照而导致数据丢失或错乱。

-----

### 思考题解析

> 我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。
>
> ```sql
> CREATE TABLE `t` (
>   `id` int(11) NOT NULL,
>   `c` int(11) DEFAULT NULL,
>   PRIMARY KEY (`id`)
> ) ENGINE=InnoDB;
> insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);
> ```

这个问题非常精彩，它完美地展示了“一致性读”和“当前读”规则碰撞时产生的奇妙现象。

#### 如何复现

你只需要打开两个会话（Session），模拟两位“时空特工”：

| 时间 | Session A (特工A) | Session B (特工B) |
| :--- | :--- | :--- |
| T1 | `begin;`\<br\>`select * from t where id=1;` (返回 c=1) | |
| T2 | | `begin;`\<br\>`update t set c=100 where id=1;` |
| T3 | | `commit;` |
| T4 | `update t set c=0 where c=1;` | |
| T5 | `select * from t;` | |
| T6 | `commit;` | |

当你执行到 **T5** 这一步，在 `Session A` 中查询全表时，你会惊奇地发现，`id=1` 这一行的数据，它的 `c` 字段**仍然是 100，而不是 0**！

也就是说，在 T4 这一步，特工A的 `update t set c=0 where c=1;` 这条命令，**并没有找到那条 `c` 曾经等于 `1` 的记录**，所以 `0 rows affected`。

#### 原理讲解

我们还是用时空特工的故事来解释这个“诡异”的现象：

1.  **T1: 特工A出发，戴上护目镜**
    特工A开启任务 (`begin`)，并执行了一次查询。此时，他的“时间静止护目镜”被校准了。在他的世界里，`id=1` 的 `c` 值**永远是 1**。

2.  **T2-T3: 外界时空发生剧变**
    特工B这位“不速之客”闯入，迅速地把 `id=1` 的 `c` 值修改成了 `100`，并**提交了这次历史变更**。此刻，在真实的时空中，`id=1` 的 `c` 值已经是 `100` 了。

3.  **T4: 特工A的“矛盾”操作**
    特工A现在要执行 `update t set c=0 where c=1;`。这个语句包含了两步操作：

      * **第一步 (找目标)：`where c=1`**
        这是 `UPDATE` 语句里**读取数据**的部分。特工A会**戴着他的护目镜**（一致性读）去寻找符合 `c=1` 的记录。他往 `id=1` 的行一看，通过护目镜的历史回溯功能，他看到的值**确实是 1**！所以，他认为 `id=1` 这行是他的目标。
      * **第二步 (修改数据)：`set c=0`**
        现在，特工A准备动手修改了。根据我们学到的规则，他必须**摘下护目镜**（当前读），去锁定那行数据的**最新版本**。他伸手去锁 `id=1` 这一行，拿到的真实数据是 `(id=1, c=100)`。
        这时，矛盾产生了！`UPDATE` 语句的内部逻辑会做一个“最终确认”：“我刚刚要修改的目标，它的真实当前值，和我透过护目镜找到它时所依据的条件，还一致吗？”
          * 护目镜告诉他，目标行的 `c` **应该是 1**。
          * 他用手触摸到的真实数据，`c` **却是 100**。
            两者**不匹配**！MySQL 判断，这行数据已经被其他人修改过了，不再满足 `where c=1` 这个条件了。因此，MySQL **决定不执行更新操作**。

4.  **T5: 验证结果**
    当特工A再次查询全表时，他仍然戴着他的护目镜，他看到的 `id=1` 的 `c` 值，是特工B修改后的值吗？不是。因为B的修改是在他出发后发生的，所以他看到的仍然是他出发时 `c=1` 的快照... 啊，不对！这里有一个更细的规则：**如果在本事务中，你尝试更新过某一行（即使没成功），当你再次查询时，为了避免逻辑混乱，你会读到这一行在数据库中最新的、已提交的值**。所以，他会看到 `c=100`。而他自己的 `update` 没有生效。

**总结**：这个“改不掉”的诡异情况，源于 `UPDATE` 语句内部的“一致性读”和“当前读”的交错。`WHERE` 条件的判断（一致性读）和真正加锁更新（当前读）之间存在一个“时间差”，如果在此期间数据被其他事务修改并提交，就可能导致更新失效。

在实际业务开发中，这种“读取-计算-写入”的模式非常常见，如果并发量高，确实可能掉进这个坑。解决方案通常是：

1.  使用 `SELECT ... FOR UPDATE`，在读取时就用“当前读”并加锁，确保你读到的就是最新的数据，并且别人无法再修改，这样后续的 `UPDATE` 就不会出现不匹配的问题。
2.  在应用层面，使用乐观锁（比如增加一个 `version` 字段）来解决。