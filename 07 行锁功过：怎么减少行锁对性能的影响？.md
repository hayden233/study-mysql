
上一章我们讲了宏观的“闭馆盘点”（全局锁）和“装修房间”（表级锁）。今天，我们把镜头拉近，看看图书馆里两位管理员，因为要同时修改**同一本书（同一行数据）**而引发的故事。

---

### 故事背景：神奇的魔法工坊

这次，我们把场景换到一个“魔法工坊”。你是一位工匠大师，你的手下有很多工匠（线程）。工坊里有很多个上了锁的“材料宝箱”（数据行）。要加工宝箱里的材料，必须先拿到对应的钥匙（行锁）。

### 第一章：只借不还的钥匙 (两阶段锁协议)

工坊里有一条铁律，叫做**“两阶段锁协议”**。这条规矩非常古怪：

1.  **借钥匙阶段**：一个工匠（事务）在做一个项目时，需要哪个宝箱的钥匙，就去钥匙架上拿。可以一个一个拿。
2.  **还钥匙阶段**：**重点来了！** 这位工匠一旦开始工作，就会变成一个“钥匙收藏家”。他**绝不会中途归还任何一把钥匙**，哪怕那个宝箱他已经用完了。他会把所有借到的钥匙一直攥在手里，直到他的整个项目**彻底完工（`COMMIT`）**或**宣布失败（`ROLLBACK`）**时，才会把所有钥匙一次性地全部还回去。

#### 这个怪癖有什么用？—— 电影票的例子

假设你的项目是“制作一张电影票”，需要三个步骤：
1.  从“顾客A的钱包”宝箱里，取出100金币。
2.  往“影院B的钱箱”宝箱里，放入100金币。
3.  在“交易日志”宝箱里，记录一笔交易。

现在的问题是，“影院B的钱箱”是个大热门，所有工匠都想往里面放钱。如果你不假思索，按 1 -> 2 -> 3 的顺序来：
* 你先拿了“顾客A钱包”的钥匙，取出金币。
* 然后你拿了“影院B钱箱”的钥匙，放入金币。**此时，这个热门的宝箱就被你锁住了！**
* 接着你慢悠悠地去拿“交易日志”的钥匙，写日志... 在你完成整个项目并归还所有钥匙之前，“影院B钱箱”的钥匙会一直被你占着，其他所有想给影院B送钱的工匠都只能在旁边排队干等着。

**正确的做法是**：
利用“两阶段锁”的特性，你应该**把最热门、最容易引起排队的那个宝箱，留到项目的最后一刻再处理**。
顺序调整为 3 -> 1 -> 2：
1.  先写交易日志。
2.  再扣顾客A的款。
3.  在万事俱备，马上就要完工的前一秒，你冲过去，迅速拿起“影院B钱箱”的钥匙，放入金币，然后立刻大喊一声“项目完工（`COMMIT`）！”并把所有钥匙瞬间还了回去。

这样，“影院B钱箱”这个热门宝箱被你占用的时间最短，工坊的整体效率（并发度）就大大提升了。

---

### 第二章：工匠的“致命拥抱” (死锁)

工坊里偶尔会发生一种诡异的僵局。
1.  工匠A 想做一个“龙凤剑”，他先拿了“龙鳞”宝箱的钥匙。
2.  与此同时，工匠B 想做一个“凤龙袍”，他先拿了“凤羽”宝箱的钥匙。
3.  接下来，工匠A 需要“凤羽”才能继续，但他发现钥匙在工匠B手里，于是他开始等待。
4.  而工匠B 也正好需要“龙鳞”才能继续，他发现钥匙在工匠A手里，于是他也开始等待。

**僵局形成了**：工匠A在等工匠B还钥匙，而工匠B在等工匠A还钥匙。他们互相等待，陷入了“致命拥抱”，如果不加干预，将永远等待下去。这就是**“死锁”**。

#### 如何解开“致命拥抱”？(死锁检测)

工坊里有一位**“监工” (Deadlock Detector)**，他的职责就是发现这种僵局。
* **消极怠工法**：监工就看着他们等。工坊规定，等待超过50秒（`innodb_lock_wait_timeout`），项目就自动失败。但50秒太长了，工坊等不起。
* **积极介入法（默认策略）**：监工非常积极。当他发现工匠A在等待时，他会立刻上前询问：“你在等谁？”“工匠B。”“好，我去看看B在干嘛。”他跑到B那里，又问：“你在等谁？”“工匠A。”
    监工立刻明白了：“好家伙，你们俩抱上了！”
    他会立刻做出决断，走到其中一人（比如工匠A）面前，说：“你的项目被取消了（`ROLLBACK`），把钥匙都还回来，然后重新开始！”
    工匠A一还钥匙，工匠B就拿到了“龙鳞”，僵局立刻解开。

---

### 第三章：监工的“过劳” (热点行更新性能问题)

“监工”的积极介入虽然好，但有一种情况会让他**“过劳死”**。

还记得那个“影院B的钱箱”吗？现在，搞周年庆活动，一瞬间来了1000个工匠，都想在同一时间往这一个宝箱里存钱。

1.  工匠1号拿到了唯一的钥匙。
2.  工匠2号到1000号，全部在门口排队等着。
3.  工匠2号开始等待时，监工跑过来，检查了一圈：“嗯，没有死锁。”
4.  工匠3号开始等待时，监工又跑过来，把2号和3号的关系都查了一遍：“嗯，没有死锁。”
5.  ...
6.  当工匠1000号开始等待时，监工要跑过来，把前面999个人的依赖关系全都梳理一遍，工作量呈指数级增长！

**结果就是**：监工（CPU）忙得满头大汗，利用率100%，但他大部分时间都在排查那1000个工匠之间有没有形成“致命拥抱”，而工匠们真正完成的项目（事务）却寥寥无几。整个工坊看起来热火朝天，但实际产出极低。

#### 如何给“监工”减负？
1.  **让他休假（关闭死锁检测）**：风险极高，不推荐。
2.  **门口限流（服务端并发控制）**：在“影院B钱箱”门口放个保安，一次只许进10个工匠排队。人少了，监工自然就轻松了。
3.  **增加钱箱（数据分片）**：这是最高明的方法。你把原来那一个“影院B的大钱箱”，换成10个“影院B的小钱箱”（0-9号）。当工匠要存钱时，随机选一个小钱箱存进去。这样，1000个工匠被分散到了10个队伍里，每个队伍只有100人，冲突概率大大降低，监工的负担也大大减轻。

### 结尾问题解析

> 如果要删除一个表里面的前10000行数据，有以下三种方法，你会选择哪一种？为什么？
> 1.  直接执行 `delete from T limit 10000;`
> 2.  在一个连接中循环执行20次 `delete from T limit 500;`
> 3.  在20个连接中同时执行 `delete from T limit 500;`

**我的选择和分析如下：**

我会选择**第二种方法**。原因如下：

* **第一种方法（单个大事务）的弊端：**
    * **持有锁时间过长**：这个操作会在一个事务里，锁住多达10000行的记录。根据我们刚学的“两阶段锁协议”，这些行锁会一直被持有到事务提交。在这期间，其他任何想要访问这10000行中任意一行的事务都会被阻塞，极大地影响了并发性。
    * **大事务风险**：执行时间长，占用的 `undo log` 也多，一旦需要回滚，成本非常高。

* **第三种方法（多连接并发）的弊弊端：**
    * **可能造成锁冲突甚至死锁**：20个连接同时冲上来，各自抢夺自己想删除的500行。如果它们之间请求加锁的顺序不一致（比如连接A想删1-500行，连接B想删501-1000行，但它们内部加锁的顺序可能因为扫描等原因变得复杂），就可能互相等待，造成锁等待甚至死锁。这会给我们的“监工”（死锁检测）带来不必要的压力。

* **第二种方法（单连接小事务循环）的优点：**
    * **锁粒度与时间都可控**：每次只锁住500行，并且执行完一次 `DELETE` 后，事务就提交了，锁会立刻被释放。然后下一个循环再申请新的500行锁。这样，每次锁定的时间和范围都大大缩小，对并发的影响最小。
    * **避免了并发冲突**：因为是在同一个连接里串行执行，所以完全没有死锁的风险。
    * **原子性平衡**：虽然不是一个绝对的原子操作（中途失败只会删除一部分），但对于“清理数据”这类维护任务来说，这种“最终一致”通常是可以接受的。我们可以在循环之间加入适当的 `sleep`，进一步减少对数据库的冲击。

**结论**：在处理大批量数据时，**“化整为零、分批处理”** 的思想，是数据库操作中一个非常重要且实用的原则。第二种方法正是这个思想的最佳体现。