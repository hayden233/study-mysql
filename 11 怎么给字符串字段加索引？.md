**如何给字符串字段创建高效的索引？**

在业务中，我们经常需要在字符串类型的字段上进行查询，比如通过邮箱、身份证号、姓名等。如果直接在这些字段上创建完整索引，当字符串很长时，索引会占用巨大空间，影响性能。这篇文章就探讨了解决这个问题的几种主流方法及其优缺点。

-----

### 1\. 核心选择：完整索引 vs. 前缀索引

假设我们有一个用户表，需要在 `email` 字段上建立索引以支持登录查询。

#### 方案A：创建完整索引

```sql
alter table SUser add index index1(email);
```

  * **工作方式**：索引中保存了每个用户完整的 `email` 字符串。
  * **优点**：非常精确。一次查询就能定位到具体记录，并且可以支持“覆盖索引”。
  * **缺点**：**占用空间大**。如果 `email` 字段长度是64字节，那么索引树中的每个节点能存放的索引项就少，导致索引树的层级可能更深，查询时的I/O次数也可能更多。

#### 方案B：创建前缀索引

```sql
alter table SUser add index index2(email(6));
```

  * **工作方式**：索引中只保存每个 `email` 字符串的**前6个字符**。
  * **优点**：**节省空间**。索引本身变得更小、更紧凑，性能可能更高。
  * **缺点（代价）**：
    1.  **可能增加“回表”次数**：如果多个 `email` 的前6个字符是相同的（比如`zhangsan@...`, `zhangsi@...`），数据库通过前缀索引找到所有以`zhangs`开头的记录后，无法确定哪条才是真正匹配的。它必须拿着这些记录的主键ID，逐一**回表**到主键索引去查询完整的`email`字段进行比对。这会增加额外的查询开销。
    2.  **无法使用“覆盖索引”**：这是一个重要的限制。即使你的查询只需要 `id` 和 `email` 字段（这两个信息理论上都在索引里），但因为前缀索引只保存了部分 `email` 信息，MySQL无法确定这个信息是否完整，所以它**必须回表**去获取最原始、最完整的`email`字符串。**使用前缀索引，就意味着放弃了覆盖索引带来的性能优化**。

### 2\. 如何选择合适的前缀长度？

既然前缀索引有好处也有坏处，那我们如何选择一个“恰到好处”的长度，既能节省空间，又不至于损失太多区分度（即增加太多查询成本）呢？

这里有一个科学的评估方法：

1.  **计算全列的区分度**：

    ```sql
    select count(distinct email) from SUser;
    ```

    这会告诉你整个 `email` 列有多少个不重复的值。

2.  **计算不同前缀长度的区分度**：

    ```sql
    select
      count(distinct left(email, 4)) as L4,
      count(distinct left(email, 5)) as L5,
      count(distinct left(email, 6)) as L6,
      count(distinct left(email, 7)) as L7
    from SUser;
    ```

3.  **进行比较**：用不同前缀的区分度除以全列的区分度，得到一个比例。比如，你可以设定一个目标，如“前缀索引的区分度不低于全列的95%”。然后你就可以找到满足这个条件的最短前缀长度。

例如，如果全列有10000个唯一值，而长度为6的前缀有9600个唯一值（区分度96%），长度为5的前缀只有9000个（区分度90%），那么选择长度为6就是一个比较合理的决策。

### 3\. 当“前缀”不给力时怎么办？

有些场景下，字符串的前几位区分度极低。比如，我们国家的身份证号，前6位是地址码，同一个地区的人都一样。这种情况下，前缀索引就失效了。我们可以采用以下两种方法来处理：

#### 方法一：字符串倒序存储 + 前缀索引

如果字符串的尾部比头部有更好的区分度（比如身份证号的后几位是顺序码和校验码），我们可以：

1.  在表中新增一个字段，专门用来存储**倒序后**的身份证号。
2.  在这个倒序的字段上建立前缀索引。
3.  查询时，对输入的查询条件也进行倒序：
    ```sql
    select * from t where id_card_reverse = reverse('input_id_card_string');
    ```

<!-- end list -->

  * **优点**：巧妙地利用了字符串尾部的高区分度，且不需额外增加太多存储空间。
  * **缺点**：不支持范围查询，且读写时都有`reverse()`函数的CPU开销。

#### 方法二：Hash字段索引

我们可以利用Hash函数，将长字符串转换成一个更短的、定长的“指纹”（通常是整数）。

1.  在表中新增一个整数字段，如`id_card_crc`。
2.  在插入数据时，使用`crc32()`等函数计算身份证号的哈希值，并存入该字段。
3.  在`id_card_crc`这个整数字段上建立索引。
4.  查询时，必须同时使用哈希值和原始值进行双重校验，以防哈希冲突：
    ```sql
    select * from t where id_card_crc=crc32('input_id_card_string') and id_card='input_id_card_string';
    ```

<!-- end list -->

  * **优点**：索引体积小（`int`只要4字节），查询性能稳定且很快（因为哈希冲突概率低）。
  * **缺点**：同样不支持范围查询，需要额外存储空间，且读写有`crc32()`的计算开销。

**两种方法的对比**：

  * **空间**：Hash字段需要一个完整的额外字段，倒序存储则不需要（但其前缀索引长度可能比4字节长）。
  * **CPU**：`reverse()`函数的开销通常比`crc32()`小。
  * **查询性能**：Hash字段的方式性能更稳定，几乎总是接近1次查询；而倒序前缀索引仍可能扫描多行。

-----

### 结尾问题解析

> 如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是`"学号@gmail.com"`，而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。
>
> 就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢？

这是一个非常好的、结合了业务场景的索引设计问题。我们来分析一下：

1.  **直接对登录名(email)建索引？**

      * **完整索引**：不可取。后缀`@gmail.com`是完全冗余的信息，会白白占用大量索引空间。
      * **前缀索引**：也不理想。登录名的前缀部分（城市、学校、年份）区分度很低，要达到比较好的区分度，可能需要索引到最后5位的顺序编号，这样前缀会非常长（比如 `10(年)+5(顺序)=15` 位），失去了前缀索引节省空间的意义。

2.  **使用倒序或者Hash？**

      * **倒序**：`moc.liamg@...`，倒序后的前缀是`moc.l`，区分度为0，完全不可行。
      * **Hash**：可行。对整个登录名做Hash，查询性能稳定。这是一个不错的备选方案。

3.  **最佳方案：利用业务规则，创建更优化的索引**
    我们仔细分析登录名`"学号@gmail.com"`，对于登录验证这个场景，**真正起作用、唯一标识用户身份的，只有“学号”这一部分**。后缀`@gmail.com`只是一个固定的格式。

    因此，最佳的设计方案是：

      * **在应用层处理**：当用户输入登录名`"111222202512345@gmail.com"`进行登录时，程序首先将`@gmail.com`后缀截掉，提取出前面的“学号”字符串`'111222202512345'`。
      * **在数据库层设计**：
        1.  在`SUser`表中，单独创建一个字段 `student_id VARCHAR(15)` 来存储纯粹的学号。
        2.  在这个 `student_id` 字段上创建一个**唯一索引**（或普通索引，取决于业务保证）。

    查询语句就变成了：

    ```sql
    select ... from SUser where student_id = 'extracted_student_id';
    ```

    **这种方案的优点：**

      * **索引最优化**：索引只包含真正有用的信息（15位学号），体积小，效率高。
      * **查询直接高效**：直接对学号进行等值查询，性能最好。
      * **设计清晰**：将业务逻辑（登录名格式）和存储结构（学号）分离，数据库设计更规范。

    在可以利用业务规则对数据进行预处理的情况下，这通常是比通用的字符串索引技巧（如Hash、倒序）更优的选择。